<?php

namespace App\Http\Controllers;

use App\Services\AiProcessorService;
use App\Services\FileManagerService;
use App\Models\Book;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Storage;
use Illuminate\Support\Facades\Log;

class AiProcessorController extends Controller
{
    private $aiProcessorService;
    private $fileManagerService;
    
    public function __construct(AiProcessorService $aiProcessorService, FileManagerService $fileManagerService)
    {
        $this->aiProcessorService = $aiProcessorService;
        $this->fileManagerService = $fileManagerService;
    }
    
    /**
     * Show AI processor interface
     */
    public function show($bookId)
    {
        // Get book files
        $files = $this->fileManagerService->getBookFiles($bookId);
        
        // Get book information from books_info table
        $bookInfo = \App\Models\BookInfo::join('books', 'books_info.book_id', '=', 'books.id')
            ->where('books.book_identify', $bookId)
            ->select('books_info.title', 'books_info.author', 'books_info.language')
            ->first();
        
        // إذا لم يتم العثور على معلومات، جرب الحصول على معلومات باللغة الافتراضية
        if (!$bookInfo) {
            $book = \App\Models\Book::where('book_identify', $bookId)->first();
            if ($book) {
                $bookInfo = $book->getBookInfoByLanguage();
            }
        }
        
        // Get processing statistics
        $processingStats = $this->getProcessingStatistics($bookId);
        
        // Debug: Log the statistics
        \Log::info('Processing Statistics for book: ' . $bookId, [
            'summarized_count' => $processingStats['summarized']->count(),
            'formatting_count' => $processingStats['formatting']->count(),
            'translated_count' => $processingStats['translated']->count(),
            'enhanced_count' => $processingStats['enhanced']->count(),
            'summarized_data' => $processingStats['summarized']->toArray(),
            'formatting_data' => $processingStats['formatting']->toArray(),
            'translated_data' => $processingStats['translated']->toArray(),
            'enhanced_data' => $processingStats['enhanced']->toArray(),
        ]);
        
        // Get available options
        $processingOptions = $this->aiProcessorService->getAvailableProcessingOptions();
        $availableLanguages = $this->aiProcessorService->getAvailableLanguages();
        
        return view('ai-processor.show', compact('bookId', 'files', 'processingOptions', 'availableLanguages', 'bookInfo', 'processingStats'));
    }
    
    /**
     * Get processing statistics for the book
     */
    private function getProcessingStatistics($bookId)
    {
        // Get book ID from book_identify
        $book = \App\Models\Book::where('book_identify', $bookId)->first();
        if (!$book) {
            return [
                'summarized' => collect(),
                'formatting' => collect(),
                'translated' => collect(),
                'enhanced' => collect(),
            ];
        }
        
        // Get statistics for each processing type and language
        $summarizedStats = \App\Models\SummarizedText::where('book_id', $book->id)
            ->selectRaw('target_language, COUNT(*) as count')
            ->groupBy('target_language')
            ->get();
            
        $formattingStats = \App\Models\FormattingImprovedText::where('book_id', $book->id)
            ->selectRaw('target_language, COUNT(*) as count')
            ->groupBy('target_language')
            ->get();
            
        $translatedStats = \App\Models\TranslatedText::where('book_id', $book->id)
            ->selectRaw('target_language, COUNT(*) as count')
            ->groupBy('target_language')
            ->get();
            
        $enhancedStats = \App\Models\EnhancedText::where('book_id', $book->id)
            ->selectRaw('target_language, COUNT(*) as count')
            ->groupBy('target_language')
            ->get();
        
        return [
            'summarized' => $summarizedStats,
            'formatting' => $formattingStats,
            'translated' => $translatedStats,
            'enhanced' => $enhancedStats,
        ];
    }
    
    /**
     * Process files with AI
     */
    public function processFiles(Request $request)
    {
        Log::info('=== AI PROCESSOR CONTROLLER START ===', [
            'request_data' => $request->all()
        ]);
        
        $request->validate([
            'book_id' => 'required|string',
            'selected_files' => 'required|array|min:1',
            'processing_options' => 'required|array|min:1|max:5', // حد أقصى 5 أنواع معالجة
            'output_method' => 'required|in:single,multiple',
            'target_language' => 'required|string',
            'offset' => 'sometimes|integer|min:0',
        ]);
        
        $results = [];
        $bookId = $request->book_id;
        $outputMethod = $request->output_method;
        $offset = (int) $request->input('offset', 0);
        $startTime = microtime(true);
        $maxDurationSeconds = (int) ($request->input('max_duration_seconds', 60)); // حد أقصى 60 ثانية افتراضياً
        $processedCount = 0;
        $filesProcessedInThisBatch = 0; // Initialize for all cases
        
        Log::info('Validation passed', [
            'book_id' => $bookId,
            'selected_files_count' => count($request->selected_files),
            'processing_options' => $request->processing_options,
            'output_method' => $outputMethod,
            'target_language' => $request->target_language,
            'offset' => $offset,
            'max_duration_seconds' => $maxDurationSeconds,
        ]);
        
        // Handle multiple processing types with smart logic
        if (count($request->processing_options) > 1 && $outputMethod === 'multiple') {
            // Multiple processing types - smart handling
            try {
                // Separate processing types
                $singleFileTypes = ['extract_info', 'blog_article']; // Types that need merged content
                $rawDiff = array_diff($request->processing_options, $singleFileTypes);
                $multipleFileTypes = array_values($rawDiff); // Types that process each file separately
                
                // Debug: Check what's happening with array_diff
                Log::info('Processing types separation', [
                    'all_options' => $request->processing_options,
                    'single_file_types' => $singleFileTypes,
                    'raw_diff' => $rawDiff,
                    'raw_diff_type' => gettype($rawDiff),
                    'raw_diff_count' => count($rawDiff),
                    'multiple_file_types' => $multipleFileTypes,
                    'multiple_file_types_type' => gettype($multipleFileTypes),
                    'multiple_file_types_count' => count($multipleFileTypes),
                    'has_single_types' => !empty(array_intersect($request->processing_options, $singleFileTypes)),
                    'has_multiple_types' => !empty($multipleFileTypes)
                ]);
                
                // 1. Process single-file types with merged content ONLY ONCE (when offset = 0)
                if (array_intersect($request->processing_options, $singleFileTypes) && $offset === 0) {
                    Log::info('Processing single-file types (ONCE ONLY)', [
                        'offset' => $offset,
                        'single_file_types' => array_intersect($request->processing_options, $singleFileTypes)
                    ]);
                    
                    $mergedContent = '';
                    $fileNames = [];
                    
                    // Process ALL files for single-file types (not just offset slice)
                    foreach ($request->selected_files as $filename) {
                        if ((microtime(true) - $startTime) >= $maxDurationSeconds) {
                            break;
                        }
                        
                        $fileContent = $this->getFileContent($bookId, $filename);
                        if ($fileContent !== false) {
                            $mergedContent .= "\n\n=== " . $filename . " ===\n\n" . $fileContent;
                            $fileNames[] = $filename;
                            $processedCount++;
                        }
                    }
                    
                    if (!empty($mergedContent)) {
                        // Process single-file types with merged content
                        $singleFileOptions = array_intersect($request->processing_options, $singleFileTypes);
                        $result = $this->aiProcessorService->processText(
                            $mergedContent,
                            array_values($singleFileOptions),
                            $request->target_language,
                            $bookId,
                            'merged_files_' . implode('_', array_slice($fileNames, 0, 3))
                        );
                        
                        $results[] = [
                            'filename' => 'ملف مدموج (' . count($fileNames) . ' ملف) - ' . implode(', ', $singleFileOptions),
                            'success' => $result['success'],
                            'text' => $result['text'] ?? null,
                            'error' => $result['error'] ?? null,
                            'processing_time' => $result['processing_time'] ?? null
                        ];
                    }
                } else {
                    Log::info('Skipping single-file types processing', [
                        'offset' => $offset,
                        'reason' => 'Already processed in first batch or not applicable'
                    ]);
                }
                
            } catch (\Exception $e) {
                Log::error('AI Processing Error for multiple types: ' . $e->getMessage());
                $results[] = [
                    'filename' => 'معالجة متعددة',
                    'success' => false,
                    'error' => 'خطأ في المعالجة المتعددة: ' . $e->getMessage()
                ];
            }
        } elseif (count($request->processing_options) > 1 && $outputMethod === 'single') {
            // Multiple processing types with SINGLE file output - merge all files first
            try {
                Log::info('Processing multiple types with single file output', [
                    'processing_options' => $request->processing_options,
                    'output_method' => $outputMethod,
                    'total_files' => count($request->selected_files)
                ]);
                
                $mergedContent = '';
                $fileNames = [];
                
                // ابدأ من offset
                $filesSlice = array_slice($request->selected_files, $offset);
                foreach ($filesSlice as $filename) {
                    if ((microtime(true) - $startTime) >= $maxDurationSeconds) {
                        break;
                    }
                    
                    $fileContent = $this->getFileContent($bookId, $filename);
                    if ($fileContent !== false) {
                        $mergedContent .= "\n\n=== " . $filename . " ===\n\n" . $fileContent;
                        $fileNames[] = $filename;
                        $processedCount++;
                        $filesProcessedInThisBatch++;
                    }
                }
                
                if (!empty($mergedContent)) {
                    // Process all types with merged content
                    $result = $this->aiProcessorService->processText(
                        $mergedContent,
                        $request->processing_options,
                        $request->target_language,
                        $bookId,
                        'merged_files_' . implode('_', array_slice($fileNames, 0, 3))
                    );
                    
                    $results[] = [
                        'filename' => 'ملف مدموج (' . count($fileNames) . ' ملف) - جميع الأنواع',
                        'success' => $result['success'],
                        'text' => $result['text'] ?? null,
                        'error' => $result['error'] ?? null,
                        'processing_time' => $result['processing_time'] ?? null
                    ];
                }
                
            } catch (\Exception $e) {
                Log::error('AI Processing Error for multiple types with single output: ' . $e->getMessage());
                $results[] = [
                    'filename' => 'ملف مدموج - جميع الأنواع',
                    'success' => false,
                    'error' => 'خطأ في معالجة الملفات المدمجة: ' . $e->getMessage()
                ];
            }
        } elseif ($outputMethod === 'single') {
            // Single processing type with single file output
            try {
                $mergedContent = '';
                $fileNames = [];
                
                // ابدأ من offset
                $filesSlice = array_slice($request->selected_files, $offset);
                foreach ($filesSlice as $filename) {
                    // تحقق من الزمن قبل كل ملف لتفادي المهلة
                    if ((microtime(true) - $startTime) >= $maxDurationSeconds) {
                        break;
                    }
                    
                    $fileContent = $this->getFileContent($bookId, $filename);
                    if ($fileContent !== false) {
                        $mergedContent .= "\n\n=== " . $filename . " ===\n\n" . $fileContent;
                        $fileNames[] = $filename;
                        $processedCount++;
                        $filesProcessedInThisBatch++;
                    }
                }
                
                if (empty($mergedContent)) {
                    return response()->json([
                        'success' => true,
                        'results' => [],
                        'has_more' => ($offset < count($request->selected_files)),
                        'next_offset' => $offset,
                    ]);
                }
                
                // Process merged content with single AI type
                $result = $this->aiProcessorService->processText(
                    $mergedContent,
                    $request->processing_options,
                    $request->target_language,
                    $bookId,
                    'merged_files_' . implode('_', array_slice($fileNames, 0, 3))
                );
                
                $results[] = [
                    'filename' => 'ملف مدموج (' . count($fileNames) . ' ملف)',
                    'success' => $result['success'],
                    'text' => $result['text'] ?? null,
                    'error' => $result['error'] ?? null,
                    'processing_time' => $result['processing_time'] ?? null
                ];
                
            } catch (\Exception $e) {
                Log::error('AI Processing Error for merged files: ' . $e->getMessage());
                $results[] = [
                    'filename' => 'ملف مدموج',
                    'success' => false,
                    'error' => 'خطأ في معالجة الملفات المدمجة: ' . $e->getMessage()
                ];
            }
                            Log::info('Processing file with types', [
                                'filename' => $filename,
                                'types_to_process' => $typesToProcess,
                                'types_count' => count($typesToProcess),
                                'types_json' => json_encode($typesToProcess)
                            ]);
                            
                            $result = $this->aiProcessorService->processText(
                                $fileContent,
                                $typesToProcess,
                                $request->target_language,
                                $bookId,
                                $filename
                            );
                            
                            $results[] = [
                                'filename' => $filename . ' - ' . implode(', ', $multipleFileTypes),
                                'success' => $result['success'],
                                'text' => $result['text'] ?? null,
                                'error' => $result['error'] ?? null,
                                'processing_time' => $result['processing_time'] ?? null
                            ];
                            $processedCount++;
                            $filesProcessedInThisBatch++;
                            
                            Log::info('File processed successfully', [
                                'filename' => $filename,
                                'success' => $result['success'],
                                'files_in_batch' => $filesProcessedInThisBatch
                            ]);
                            
                        } catch (\Exception $e) {
                            Log::error('AI Processing Error for file ' . $filename . ': ' . $e->getMessage());
                            $results[] = [
                                'filename' => $filename,
                                'success' => false,
                                'error' => 'خطأ في معالجة الملف: ' . $e->getMessage()
                            ];
                            $processedCount++;
                            $filesProcessedInThisBatch++;
                        }
                    }
                }
                
                // Log batch completion for multiple-file types
                Log::info('Multiple-file types batch completed', [
                    'files_processed_in_batch' => $filesProcessedInThisBatch,
                    'total_processed' => $processedCount,
                    'total_files' => count($request->selected_files),
                    'has_more' => ($processedCount < count($request->selected_files))
                ]);
                
            } catch (\Exception $e) {
                Log::error('AI Processing Error for multiple types: ' . $e->getMessage());
                $results[] = [
                    'filename' => 'معالجة متعددة',
                    'success' => false,
                    'error' => 'خطأ في المعالجة المتعددة: ' . $e->getMessage()
                ];
            }
        } elseif ($outputMethod === 'single') {
            // Single processing type with single file output
            try {
                $mergedContent = '';
                $fileNames = [];
                
                // ابدأ من offset
                $filesSlice = array_slice($request->selected_files, $offset);
                foreach ($filesSlice as $filename) {
                    // تحقق من الزمن قبل كل ملف لتفادي المهلة
                    if ((microtime(true) - $startTime) >= $maxDurationSeconds) {
                        break;
                    }
                    
                    $fileContent = $this->getFileContent($bookId, $filename);
                    if ($fileContent !== false) {
                        $mergedContent .= "\n\n=== " . $filename . " ===\n\n" . $fileContent;
                        $fileNames[] = $filename;
                        $processedCount++;
                        $filesProcessedInThisBatch++;
                    }
                }
                
                if (empty($mergedContent)) {
                    return response()->json([
                        'success' => true,
                        'results' => [],
                        'has_more' => ($offset < count($request->selected_files)),
                        'next_offset' => $offset,
                    ]);
                }
                
                // Process merged content with single AI type
                $result = $this->aiProcessorService->processText(
                    $mergedContent,
                    $request->processing_options,
                    $request->target_language,
                    $bookId,
                    'merged_files_' . implode('_', array_slice($fileNames, 0, 3))
                );
                
                $results[] = [
                    'filename' => 'ملف مدموج (' . count($fileNames) . ' ملف)',
                    'success' => $result['success'],
                    'text' => $result['text'] ?? null,
                    'error' => $result['error'] ?? null,
                    'processing_time' => $result['processing_time'] ?? null
                ];
                
            } catch (\Exception $e) {
                Log::error('AI Processing Error for merged files: ' . $e->getMessage());
                $results[] = [
                    'filename' => 'ملف مدموج',
                    'success' => false,
                    'error' => 'خطأ في معالجة الملفات المدمجة: ' . $e->getMessage()
                ];
            }
        } else {
            // Handle multiple files output method with time slicing
            $files = array_slice($request->selected_files, $offset);
            foreach ($files as $filename) {
                // تحقق من الزمن قبل كل ملف لتفادي مهلة Nginx/Cloudflare
                if ((microtime(true) - $startTime) >= $maxDurationSeconds) {
                    Log::info('Time limit reached for this batch', [
                        'elapsed' => round(microtime(true) - $startTime, 2)
                    ]);
                    break;
                }
                
                Log::info('Processing file', [
                    'filename' => $filename,
                    'book_identify' => $bookId
                ]);
                
                try {
                    $fileContent = $this->getFileContent($bookId, $filename);
                    
                    if ($fileContent === false) {
                        Log::error('File content not found', [
                            'filename' => $filename,
                            'book_identify' => $bookId
                        ]);
                        $results[] = [
                            'filename' => $filename,
                            'success' => false,
                            'error' => 'لا يمكن قراءة الملف'
                        ];
                        $processedCount++;
                        continue;
                    }
                    
                    Log::info('File content loaded', [
                        'filename' => $filename,
                        'content_length' => strlen($fileContent)
                    ]);
                    
                    $result = $this->aiProcessorService->processText(
                        $fileContent,
                        $request->processing_options,
                        $request->target_language,
                        $bookId,
                        $filename
                    );
                    
                    Log::info('AI processing result', [
                        'filename' => $filename,
                        'success' => $result['success'],
                        'has_text' => isset($result['text']),
                        'has_error' => isset($result['error']),
                        'processing_time' => $result['processing_time'] ?? null
                    ]);
                    
                    $results[] = [
                        'filename' => $filename,
                        'success' => $result['success'],
                        'text' => $result['text'] ?? null,
                        'error' => $result['error'] ?? null,
                        'processing_time' => $result['processing_time'] ?? null
                    ];
                    $processedCount++;
                    $filesProcessedInThisBatch++;
                    
                } catch (\Exception $e) {
                    Log::error('AI Processing Error for file ' . $filename . ': ' . $e->getMessage());
                    
                    $results[] = [
                        'filename' => $filename,
                        'success' => false,
                        'error' => 'خطأ في معالجة الملف: ' . $e->getMessage()
                    ];
                    $processedCount++;
                    $filesProcessedInThisBatch++;
                }
            }
        }
        
        $totalSelected = count($request->selected_files);
        
        // Calculate next offset based on actual files processed
        if (count($request->processing_options) > 1) {
            // For multiple processing types, use the actual offset + files processed in this batch
            $nextOffset = $offset + $filesProcessedInThisBatch;
        } else {
            // For single processing type, use the original logic
            $nextOffset = $offset + $processedCount;
        }
        
        $hasMore = $nextOffset < $totalSelected;
        
        Log::info('Offset calculation', [
            'original_offset' => $offset,
            'processed_count' => $processedCount,
            'files_processed_in_batch' => $filesProcessedInThisBatch ?? 0,
            'next_offset' => $nextOffset,
            'total_selected' => $totalSelected,
            'has_more' => $hasMore
        ]);
        
        Log::info('=== AI PROCESSOR CONTROLLER COMPLETED ===', [
            'total_files' => $totalSelected,
            'processed_in_batch' => $processedCount,
            'next_offset' => $nextOffset,
            'has_more' => $hasMore,
            'output_method' => $outputMethod,
            'successful_results' => count(array_filter($results, fn($r) => $r['success'])),
            'failed_results' => count(array_filter($results, fn($r) => !$r['success']))
        ]);
        
        return response()->json([
            'success' => true,
            'results' => $results,
            'has_more' => $hasMore,
            'next_offset' => $nextOffset,
        ]);
    }
    
    /**
     * Get file content
     */
    private function getFileContent($bookIdentify, $filename)
    {
        Log::info('Getting file content', [
            'book_identify' => $bookIdentify,
            'filename' => $filename
        ]);
        
        try {
            // Try to find the file in extracted_texts folder
            $filePath = storage_path('app/public/extracted_texts/' . $bookIdentify . '/' . $filename);
            
            Log::info('Checking extracted_texts path', [
                'path' => $filePath,
                'exists' => file_exists($filePath)
            ]);
            
            if (!file_exists($filePath)) {
                // Try processed_texts folder
                $filePath = storage_path('app/public/processed_texts/' . $bookIdentify . '/' . $filename);
                
                Log::info('Checking processed_texts path', [
                    'path' => $filePath,
                    'exists' => file_exists($filePath)
                ]);
            }
            
            if (!file_exists($filePath)) {
                Log::error('File not found in any location', [
                    'book_identify' => $bookIdentify,
                    'filename' => $filename,
                    'extracted_path' => storage_path('app/public/extracted_texts/' . $bookIdentify . '/' . $filename),
                    'processed_path' => storage_path('app/public/processed_texts/' . $bookIdentify . '/' . $filename)
                ]);
                return false;
            }
            
            $content = file_get_contents($filePath);
            Log::info('File content loaded successfully', [
                'path' => $filePath,
                'content_length' => strlen($content)
            ]);
            
            return $content;
            
        } catch (\Exception $e) {
            Log::error('Error reading file: ' . $e->getMessage(), [
                'book_identify' => $bookIdentify,
                'filename' => $filename,
                'error' => $e->getMessage()
            ]);
            return false;
        }
    }
    
    /**
     * Get processing history
     */
    public function getProcessingHistory($bookIdentify)
    {
        // Get actual book ID from book_identify
        $book = \App\Models\Book::where('book_identify', $bookIdentify)->first();
        if (!$book) {
            return response()->json([
                'success' => true,
                'history' => []
            ]);
        }
        
        $limit = request('limit', 10); // Default to 10 records
        $offset = request('offset', 0);
        
        $history = \App\Models\ProcessingHistory::where('book_id', $book->id)
            ->orderBy('created_at', 'desc')
            ->limit($limit)
            ->offset($offset)
            ->get();
            
        $totalCount = \App\Models\ProcessingHistory::where('book_id', $book->id)->count();
            
        return response()->json([
            'success' => true,
            'history' => $history,
            'total_count' => $totalCount,
            'has_more' => ($offset + $limit) < $totalCount
        ]);
    }
    
    /**
     * Get processed texts
     */
    public function getProcessedTexts($bookIdentify)
    {
        // Get actual book ID from book_identify
        $book = \App\Models\Book::where('book_identify', $bookIdentify)->first();
        if (!$book) {
            return response()->json([
                'success' => true,
                'enhanced_texts' => [],
                'translated_texts' => [],
                'summarized_texts' => [],
                'language_improved_texts' => [],
                'formatting_improved_texts' => [],
            ]);
        }
        
        $enhancedTexts = \App\Models\EnhancedText::where('book_id', $book->id)->get();
        $translatedTexts = \App\Models\TranslatedText::where('book_id', $book->id)->get();
        $summarizedTexts = \App\Models\SummarizedText::where('book_id', $book->id)->get();
        $languageImprovedTexts = \App\Models\LanguageImprovedText::where('book_id', $book->id)->get();
        $formattingImprovedTexts = \App\Models\FormattingImprovedText::where('book_id', $book->id)->get();
        
        return response()->json([
            'success' => true,
            'enhanced_texts' => $enhancedTexts,
            'translated_texts' => $translatedTexts,
            'summarized_texts' => $summarizedTexts,
            'language_improved_texts' => $languageImprovedTexts,
            'formatting_improved_texts' => $formattingImprovedTexts,
        ]);
    }
} 